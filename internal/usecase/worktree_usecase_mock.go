// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package usecase

import (
	"context"

	"github.com/auto-devs/auto-devs/internal/entity"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewWorktreeUsecaseMock creates a new instance of WorktreeUsecaseMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewWorktreeUsecaseMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *WorktreeUsecaseMock {
	mock := &WorktreeUsecaseMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// WorktreeUsecaseMock is an autogenerated mock type for the WorktreeUsecase type
type WorktreeUsecaseMock struct {
	mock.Mock
}

type WorktreeUsecaseMock_Expecter struct {
	mock *mock.Mock
}

func (_m *WorktreeUsecaseMock) EXPECT() *WorktreeUsecaseMock_Expecter {
	return &WorktreeUsecaseMock_Expecter{mock: &_m.Mock}
}

// CleanupWorktreeForTask provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) CleanupWorktreeForTask(ctx context.Context, req CleanupWorktreeRequest) error {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CleanupWorktreeForTask")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, CleanupWorktreeRequest) error); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_CleanupWorktreeForTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupWorktreeForTask'
type WorktreeUsecaseMock_CleanupWorktreeForTask_Call struct {
	*mock.Call
}

// CleanupWorktreeForTask is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *WorktreeUsecaseMock_Expecter) CleanupWorktreeForTask(ctx interface{}, req interface{}) *WorktreeUsecaseMock_CleanupWorktreeForTask_Call {
	return &WorktreeUsecaseMock_CleanupWorktreeForTask_Call{Call: _e.mock.On("CleanupWorktreeForTask", ctx, req)}
}

func (_c *WorktreeUsecaseMock_CleanupWorktreeForTask_Call) Run(run func(ctx context.Context, req CleanupWorktreeRequest)) *WorktreeUsecaseMock_CleanupWorktreeForTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CleanupWorktreeRequest))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_CleanupWorktreeForTask_Call) Return(err error) *WorktreeUsecaseMock_CleanupWorktreeForTask_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_CleanupWorktreeForTask_Call) RunAndReturn(run func(ctx context.Context, req CleanupWorktreeRequest) error) *WorktreeUsecaseMock_CleanupWorktreeForTask_Call {
	_c.Call.Return(run)
	return _c
}

// CopyConfigurationFiles provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) CopyConfigurationFiles(ctx context.Context, worktreeID uuid.UUID, sourcePath string) error {
	ret := _mock.Called(ctx, worktreeID, sourcePath)

	if len(ret) == 0 {
		panic("no return value specified for CopyConfigurationFiles")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) error); ok {
		r0 = returnFunc(ctx, worktreeID, sourcePath)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_CopyConfigurationFiles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyConfigurationFiles'
type WorktreeUsecaseMock_CopyConfigurationFiles_Call struct {
	*mock.Call
}

// CopyConfigurationFiles is a helper method to define mock.On call
//   - ctx
//   - worktreeID
//   - sourcePath
func (_e *WorktreeUsecaseMock_Expecter) CopyConfigurationFiles(ctx interface{}, worktreeID interface{}, sourcePath interface{}) *WorktreeUsecaseMock_CopyConfigurationFiles_Call {
	return &WorktreeUsecaseMock_CopyConfigurationFiles_Call{Call: _e.mock.On("CopyConfigurationFiles", ctx, worktreeID, sourcePath)}
}

func (_c *WorktreeUsecaseMock_CopyConfigurationFiles_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID, sourcePath string)) *WorktreeUsecaseMock_CopyConfigurationFiles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_CopyConfigurationFiles_Call) Return(err error) *WorktreeUsecaseMock_CopyConfigurationFiles_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_CopyConfigurationFiles_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID, sourcePath string) error) *WorktreeUsecaseMock_CopyConfigurationFiles_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBranchForTask provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) CreateBranchForTask(ctx context.Context, taskID uuid.UUID, branchName string) error {
	ret := _mock.Called(ctx, taskID, branchName)

	if len(ret) == 0 {
		panic("no return value specified for CreateBranchForTask")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) error); ok {
		r0 = returnFunc(ctx, taskID, branchName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_CreateBranchForTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBranchForTask'
type WorktreeUsecaseMock_CreateBranchForTask_Call struct {
	*mock.Call
}

// CreateBranchForTask is a helper method to define mock.On call
//   - ctx
//   - taskID
//   - branchName
func (_e *WorktreeUsecaseMock_Expecter) CreateBranchForTask(ctx interface{}, taskID interface{}, branchName interface{}) *WorktreeUsecaseMock_CreateBranchForTask_Call {
	return &WorktreeUsecaseMock_CreateBranchForTask_Call{Call: _e.mock.On("CreateBranchForTask", ctx, taskID, branchName)}
}

func (_c *WorktreeUsecaseMock_CreateBranchForTask_Call) Run(run func(ctx context.Context, taskID uuid.UUID, branchName string)) *WorktreeUsecaseMock_CreateBranchForTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_CreateBranchForTask_Call) Return(err error) *WorktreeUsecaseMock_CreateBranchForTask_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_CreateBranchForTask_Call) RunAndReturn(run func(ctx context.Context, taskID uuid.UUID, branchName string) error) *WorktreeUsecaseMock_CreateBranchForTask_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorktreeForTask provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) CreateWorktreeForTask(ctx context.Context, req CreateWorktreeRequest) (*entity.Worktree, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorktreeForTask")
	}

	var r0 *entity.Worktree
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, CreateWorktreeRequest) (*entity.Worktree, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, CreateWorktreeRequest) *entity.Worktree); ok {
		r0 = returnFunc(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Worktree)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, CreateWorktreeRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_CreateWorktreeForTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorktreeForTask'
type WorktreeUsecaseMock_CreateWorktreeForTask_Call struct {
	*mock.Call
}

// CreateWorktreeForTask is a helper method to define mock.On call
//   - ctx
//   - req
func (_e *WorktreeUsecaseMock_Expecter) CreateWorktreeForTask(ctx interface{}, req interface{}) *WorktreeUsecaseMock_CreateWorktreeForTask_Call {
	return &WorktreeUsecaseMock_CreateWorktreeForTask_Call{Call: _e.mock.On("CreateWorktreeForTask", ctx, req)}
}

func (_c *WorktreeUsecaseMock_CreateWorktreeForTask_Call) Run(run func(ctx context.Context, req CreateWorktreeRequest)) *WorktreeUsecaseMock_CreateWorktreeForTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(CreateWorktreeRequest))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_CreateWorktreeForTask_Call) Return(worktree *entity.Worktree, err error) *WorktreeUsecaseMock_CreateWorktreeForTask_Call {
	_c.Call.Return(worktree, err)
	return _c
}

func (_c *WorktreeUsecaseMock_CreateWorktreeForTask_Call) RunAndReturn(run func(ctx context.Context, req CreateWorktreeRequest) (*entity.Worktree, error)) *WorktreeUsecaseMock_CreateWorktreeForTask_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveWorktreesCount provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetActiveWorktreesCount(ctx context.Context, projectID uuid.UUID) (int, error) {
	ret := _mock.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveWorktreesCount")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (int, error)); ok {
		return returnFunc(ctx, projectID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) int); ok {
		r0 = returnFunc(ctx, projectID)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetActiveWorktreesCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveWorktreesCount'
type WorktreeUsecaseMock_GetActiveWorktreesCount_Call struct {
	*mock.Call
}

// GetActiveWorktreesCount is a helper method to define mock.On call
//   - ctx
//   - projectID
func (_e *WorktreeUsecaseMock_Expecter) GetActiveWorktreesCount(ctx interface{}, projectID interface{}) *WorktreeUsecaseMock_GetActiveWorktreesCount_Call {
	return &WorktreeUsecaseMock_GetActiveWorktreesCount_Call{Call: _e.mock.On("GetActiveWorktreesCount", ctx, projectID)}
}

func (_c *WorktreeUsecaseMock_GetActiveWorktreesCount_Call) Run(run func(ctx context.Context, projectID uuid.UUID)) *WorktreeUsecaseMock_GetActiveWorktreesCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetActiveWorktreesCount_Call) Return(n int, err error) *WorktreeUsecaseMock_GetActiveWorktreesCount_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetActiveWorktreesCount_Call) RunAndReturn(run func(ctx context.Context, projectID uuid.UUID) (int, error)) *WorktreeUsecaseMock_GetActiveWorktreesCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetBranchInfo provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetBranchInfo(ctx context.Context, worktreeID uuid.UUID) (*BranchInfo, error) {
	ret := _mock.Called(ctx, worktreeID)

	if len(ret) == 0 {
		panic("no return value specified for GetBranchInfo")
	}

	var r0 *BranchInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*BranchInfo, error)); ok {
		return returnFunc(ctx, worktreeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *BranchInfo); ok {
		r0 = returnFunc(ctx, worktreeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BranchInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, worktreeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetBranchInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBranchInfo'
type WorktreeUsecaseMock_GetBranchInfo_Call struct {
	*mock.Call
}

// GetBranchInfo is a helper method to define mock.On call
//   - ctx
//   - worktreeID
func (_e *WorktreeUsecaseMock_Expecter) GetBranchInfo(ctx interface{}, worktreeID interface{}) *WorktreeUsecaseMock_GetBranchInfo_Call {
	return &WorktreeUsecaseMock_GetBranchInfo_Call{Call: _e.mock.On("GetBranchInfo", ctx, worktreeID)}
}

func (_c *WorktreeUsecaseMock_GetBranchInfo_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID)) *WorktreeUsecaseMock_GetBranchInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetBranchInfo_Call) Return(branchInfo *BranchInfo, err error) *WorktreeUsecaseMock_GetBranchInfo_Call {
	_c.Call.Return(branchInfo, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetBranchInfo_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID) (*BranchInfo, error)) *WorktreeUsecaseMock_GetBranchInfo_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorktreeByTaskID provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetWorktreeByTaskID(ctx context.Context, taskID uuid.UUID) (*entity.Worktree, error) {
	ret := _mock.Called(ctx, taskID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorktreeByTaskID")
	}

	var r0 *entity.Worktree
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*entity.Worktree, error)); ok {
		return returnFunc(ctx, taskID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *entity.Worktree); ok {
		r0 = returnFunc(ctx, taskID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Worktree)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, taskID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetWorktreeByTaskID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorktreeByTaskID'
type WorktreeUsecaseMock_GetWorktreeByTaskID_Call struct {
	*mock.Call
}

// GetWorktreeByTaskID is a helper method to define mock.On call
//   - ctx
//   - taskID
func (_e *WorktreeUsecaseMock_Expecter) GetWorktreeByTaskID(ctx interface{}, taskID interface{}) *WorktreeUsecaseMock_GetWorktreeByTaskID_Call {
	return &WorktreeUsecaseMock_GetWorktreeByTaskID_Call{Call: _e.mock.On("GetWorktreeByTaskID", ctx, taskID)}
}

func (_c *WorktreeUsecaseMock_GetWorktreeByTaskID_Call) Run(run func(ctx context.Context, taskID uuid.UUID)) *WorktreeUsecaseMock_GetWorktreeByTaskID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeByTaskID_Call) Return(worktree *entity.Worktree, err error) *WorktreeUsecaseMock_GetWorktreeByTaskID_Call {
	_c.Call.Return(worktree, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeByTaskID_Call) RunAndReturn(run func(ctx context.Context, taskID uuid.UUID) (*entity.Worktree, error)) *WorktreeUsecaseMock_GetWorktreeByTaskID_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorktreeHealth provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetWorktreeHealth(ctx context.Context, worktreeID uuid.UUID) (*WorktreeHealthInfo, error) {
	ret := _mock.Called(ctx, worktreeID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorktreeHealth")
	}

	var r0 *WorktreeHealthInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*WorktreeHealthInfo, error)); ok {
		return returnFunc(ctx, worktreeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *WorktreeHealthInfo); ok {
		r0 = returnFunc(ctx, worktreeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorktreeHealthInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, worktreeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetWorktreeHealth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorktreeHealth'
type WorktreeUsecaseMock_GetWorktreeHealth_Call struct {
	*mock.Call
}

// GetWorktreeHealth is a helper method to define mock.On call
//   - ctx
//   - worktreeID
func (_e *WorktreeUsecaseMock_Expecter) GetWorktreeHealth(ctx interface{}, worktreeID interface{}) *WorktreeUsecaseMock_GetWorktreeHealth_Call {
	return &WorktreeUsecaseMock_GetWorktreeHealth_Call{Call: _e.mock.On("GetWorktreeHealth", ctx, worktreeID)}
}

func (_c *WorktreeUsecaseMock_GetWorktreeHealth_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID)) *WorktreeUsecaseMock_GetWorktreeHealth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeHealth_Call) Return(worktreeHealthInfo *WorktreeHealthInfo, err error) *WorktreeUsecaseMock_GetWorktreeHealth_Call {
	_c.Call.Return(worktreeHealthInfo, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeHealth_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID) (*WorktreeHealthInfo, error)) *WorktreeUsecaseMock_GetWorktreeHealth_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorktreeStatistics provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetWorktreeStatistics(ctx context.Context, projectID uuid.UUID) (*entity.WorktreeStatistics, error) {
	ret := _mock.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorktreeStatistics")
	}

	var r0 *entity.WorktreeStatistics
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*entity.WorktreeStatistics, error)); ok {
		return returnFunc(ctx, projectID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *entity.WorktreeStatistics); ok {
		r0 = returnFunc(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.WorktreeStatistics)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetWorktreeStatistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorktreeStatistics'
type WorktreeUsecaseMock_GetWorktreeStatistics_Call struct {
	*mock.Call
}

// GetWorktreeStatistics is a helper method to define mock.On call
//   - ctx
//   - projectID
func (_e *WorktreeUsecaseMock_Expecter) GetWorktreeStatistics(ctx interface{}, projectID interface{}) *WorktreeUsecaseMock_GetWorktreeStatistics_Call {
	return &WorktreeUsecaseMock_GetWorktreeStatistics_Call{Call: _e.mock.On("GetWorktreeStatistics", ctx, projectID)}
}

func (_c *WorktreeUsecaseMock_GetWorktreeStatistics_Call) Run(run func(ctx context.Context, projectID uuid.UUID)) *WorktreeUsecaseMock_GetWorktreeStatistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeStatistics_Call) Return(worktreeStatistics *entity.WorktreeStatistics, err error) *WorktreeUsecaseMock_GetWorktreeStatistics_Call {
	_c.Call.Return(worktreeStatistics, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreeStatistics_Call) RunAndReturn(run func(ctx context.Context, projectID uuid.UUID) (*entity.WorktreeStatistics, error)) *WorktreeUsecaseMock_GetWorktreeStatistics_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorktreesByProjectID provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) GetWorktreesByProjectID(ctx context.Context, projectID uuid.UUID) ([]*entity.Worktree, error) {
	ret := _mock.Called(ctx, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetWorktreesByProjectID")
	}

	var r0 []*entity.Worktree
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*entity.Worktree, error)); ok {
		return returnFunc(ctx, projectID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*entity.Worktree); ok {
		r0 = returnFunc(ctx, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Worktree)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, projectID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_GetWorktreesByProjectID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorktreesByProjectID'
type WorktreeUsecaseMock_GetWorktreesByProjectID_Call struct {
	*mock.Call
}

// GetWorktreesByProjectID is a helper method to define mock.On call
//   - ctx
//   - projectID
func (_e *WorktreeUsecaseMock_Expecter) GetWorktreesByProjectID(ctx interface{}, projectID interface{}) *WorktreeUsecaseMock_GetWorktreesByProjectID_Call {
	return &WorktreeUsecaseMock_GetWorktreesByProjectID_Call{Call: _e.mock.On("GetWorktreesByProjectID", ctx, projectID)}
}

func (_c *WorktreeUsecaseMock_GetWorktreesByProjectID_Call) Run(run func(ctx context.Context, projectID uuid.UUID)) *WorktreeUsecaseMock_GetWorktreesByProjectID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreesByProjectID_Call) Return(worktrees []*entity.Worktree, err error) *WorktreeUsecaseMock_GetWorktreesByProjectID_Call {
	_c.Call.Return(worktrees, err)
	return _c
}

func (_c *WorktreeUsecaseMock_GetWorktreesByProjectID_Call) RunAndReturn(run func(ctx context.Context, projectID uuid.UUID) ([]*entity.Worktree, error)) *WorktreeUsecaseMock_GetWorktreesByProjectID_Call {
	_c.Call.Return(run)
	return _c
}

// HandleWorktreeCreationFailure provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) HandleWorktreeCreationFailure(ctx context.Context, taskID uuid.UUID, error1 error) error {
	ret := _mock.Called(ctx, taskID, error1)

	if len(ret) == 0 {
		panic("no return value specified for HandleWorktreeCreationFailure")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, error) error); ok {
		r0 = returnFunc(ctx, taskID, error1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HandleWorktreeCreationFailure'
type WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call struct {
	*mock.Call
}

// HandleWorktreeCreationFailure is a helper method to define mock.On call
//   - ctx
//   - taskID
//   - error1
func (_e *WorktreeUsecaseMock_Expecter) HandleWorktreeCreationFailure(ctx interface{}, taskID interface{}, error1 interface{}) *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call {
	return &WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call{Call: _e.mock.On("HandleWorktreeCreationFailure", ctx, taskID, error1)}
}

func (_c *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call) Run(run func(ctx context.Context, taskID uuid.UUID, error1 error)) *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(error))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call) Return(err error) *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call) RunAndReturn(run func(ctx context.Context, taskID uuid.UUID, error1 error) error) *WorktreeUsecaseMock_HandleWorktreeCreationFailure_Call {
	_c.Call.Return(run)
	return _c
}

// InitializeWorktree provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) InitializeWorktree(ctx context.Context, worktreeID uuid.UUID) error {
	ret := _mock.Called(ctx, worktreeID)

	if len(ret) == 0 {
		panic("no return value specified for InitializeWorktree")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, worktreeID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_InitializeWorktree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'InitializeWorktree'
type WorktreeUsecaseMock_InitializeWorktree_Call struct {
	*mock.Call
}

// InitializeWorktree is a helper method to define mock.On call
//   - ctx
//   - worktreeID
func (_e *WorktreeUsecaseMock_Expecter) InitializeWorktree(ctx interface{}, worktreeID interface{}) *WorktreeUsecaseMock_InitializeWorktree_Call {
	return &WorktreeUsecaseMock_InitializeWorktree_Call{Call: _e.mock.On("InitializeWorktree", ctx, worktreeID)}
}

func (_c *WorktreeUsecaseMock_InitializeWorktree_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID)) *WorktreeUsecaseMock_InitializeWorktree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_InitializeWorktree_Call) Return(err error) *WorktreeUsecaseMock_InitializeWorktree_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_InitializeWorktree_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID) error) *WorktreeUsecaseMock_InitializeWorktree_Call {
	_c.Call.Return(run)
	return _c
}

// RecoverFailedWorktree provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) RecoverFailedWorktree(ctx context.Context, worktreeID uuid.UUID) error {
	ret := _mock.Called(ctx, worktreeID)

	if len(ret) == 0 {
		panic("no return value specified for RecoverFailedWorktree")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, worktreeID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_RecoverFailedWorktree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecoverFailedWorktree'
type WorktreeUsecaseMock_RecoverFailedWorktree_Call struct {
	*mock.Call
}

// RecoverFailedWorktree is a helper method to define mock.On call
//   - ctx
//   - worktreeID
func (_e *WorktreeUsecaseMock_Expecter) RecoverFailedWorktree(ctx interface{}, worktreeID interface{}) *WorktreeUsecaseMock_RecoverFailedWorktree_Call {
	return &WorktreeUsecaseMock_RecoverFailedWorktree_Call{Call: _e.mock.On("RecoverFailedWorktree", ctx, worktreeID)}
}

func (_c *WorktreeUsecaseMock_RecoverFailedWorktree_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID)) *WorktreeUsecaseMock_RecoverFailedWorktree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_RecoverFailedWorktree_Call) Return(err error) *WorktreeUsecaseMock_RecoverFailedWorktree_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_RecoverFailedWorktree_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID) error) *WorktreeUsecaseMock_RecoverFailedWorktree_Call {
	_c.Call.Return(run)
	return _c
}

// SwitchToBranch provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) SwitchToBranch(ctx context.Context, worktreeID uuid.UUID, branchName string) error {
	ret := _mock.Called(ctx, worktreeID, branchName)

	if len(ret) == 0 {
		panic("no return value specified for SwitchToBranch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) error); ok {
		r0 = returnFunc(ctx, worktreeID, branchName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_SwitchToBranch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SwitchToBranch'
type WorktreeUsecaseMock_SwitchToBranch_Call struct {
	*mock.Call
}

// SwitchToBranch is a helper method to define mock.On call
//   - ctx
//   - worktreeID
//   - branchName
func (_e *WorktreeUsecaseMock_Expecter) SwitchToBranch(ctx interface{}, worktreeID interface{}, branchName interface{}) *WorktreeUsecaseMock_SwitchToBranch_Call {
	return &WorktreeUsecaseMock_SwitchToBranch_Call{Call: _e.mock.On("SwitchToBranch", ctx, worktreeID, branchName)}
}

func (_c *WorktreeUsecaseMock_SwitchToBranch_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID, branchName string)) *WorktreeUsecaseMock_SwitchToBranch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_SwitchToBranch_Call) Return(err error) *WorktreeUsecaseMock_SwitchToBranch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_SwitchToBranch_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID, branchName string) error) *WorktreeUsecaseMock_SwitchToBranch_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWorktreeStatus provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) UpdateWorktreeStatus(ctx context.Context, worktreeID uuid.UUID, status entity.WorktreeStatus) error {
	ret := _mock.Called(ctx, worktreeID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWorktreeStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, entity.WorktreeStatus) error); ok {
		r0 = returnFunc(ctx, worktreeID, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// WorktreeUsecaseMock_UpdateWorktreeStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWorktreeStatus'
type WorktreeUsecaseMock_UpdateWorktreeStatus_Call struct {
	*mock.Call
}

// UpdateWorktreeStatus is a helper method to define mock.On call
//   - ctx
//   - worktreeID
//   - status
func (_e *WorktreeUsecaseMock_Expecter) UpdateWorktreeStatus(ctx interface{}, worktreeID interface{}, status interface{}) *WorktreeUsecaseMock_UpdateWorktreeStatus_Call {
	return &WorktreeUsecaseMock_UpdateWorktreeStatus_Call{Call: _e.mock.On("UpdateWorktreeStatus", ctx, worktreeID, status)}
}

func (_c *WorktreeUsecaseMock_UpdateWorktreeStatus_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID, status entity.WorktreeStatus)) *WorktreeUsecaseMock_UpdateWorktreeStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(entity.WorktreeStatus))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_UpdateWorktreeStatus_Call) Return(err error) *WorktreeUsecaseMock_UpdateWorktreeStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *WorktreeUsecaseMock_UpdateWorktreeStatus_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID, status entity.WorktreeStatus) error) *WorktreeUsecaseMock_UpdateWorktreeStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateWorktree provides a mock function for the type WorktreeUsecaseMock
func (_mock *WorktreeUsecaseMock) ValidateWorktree(ctx context.Context, worktreeID uuid.UUID) (*WorktreeValidationResult, error) {
	ret := _mock.Called(ctx, worktreeID)

	if len(ret) == 0 {
		panic("no return value specified for ValidateWorktree")
	}

	var r0 *WorktreeValidationResult
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*WorktreeValidationResult, error)); ok {
		return returnFunc(ctx, worktreeID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *WorktreeValidationResult); ok {
		r0 = returnFunc(ctx, worktreeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*WorktreeValidationResult)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, worktreeID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// WorktreeUsecaseMock_ValidateWorktree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateWorktree'
type WorktreeUsecaseMock_ValidateWorktree_Call struct {
	*mock.Call
}

// ValidateWorktree is a helper method to define mock.On call
//   - ctx
//   - worktreeID
func (_e *WorktreeUsecaseMock_Expecter) ValidateWorktree(ctx interface{}, worktreeID interface{}) *WorktreeUsecaseMock_ValidateWorktree_Call {
	return &WorktreeUsecaseMock_ValidateWorktree_Call{Call: _e.mock.On("ValidateWorktree", ctx, worktreeID)}
}

func (_c *WorktreeUsecaseMock_ValidateWorktree_Call) Run(run func(ctx context.Context, worktreeID uuid.UUID)) *WorktreeUsecaseMock_ValidateWorktree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *WorktreeUsecaseMock_ValidateWorktree_Call) Return(worktreeValidationResult *WorktreeValidationResult, err error) *WorktreeUsecaseMock_ValidateWorktree_Call {
	_c.Call.Return(worktreeValidationResult, err)
	return _c
}

func (_c *WorktreeUsecaseMock_ValidateWorktree_Call) RunAndReturn(run func(ctx context.Context, worktreeID uuid.UUID) (*WorktreeValidationResult, error)) *WorktreeUsecaseMock_ValidateWorktree_Call {
	_c.Call.Return(run)
	return _c
}
