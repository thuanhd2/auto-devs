// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package repository

import (
	"context"
	"time"

	"github.com/auto-devs/auto-devs/internal/entity"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewProcessRepositoryMock creates a new instance of ProcessRepositoryMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProcessRepositoryMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProcessRepositoryMock {
	mock := &ProcessRepositoryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ProcessRepositoryMock is an autogenerated mock type for the ProcessRepository type
type ProcessRepositoryMock struct {
	mock.Mock
}

type ProcessRepositoryMock_Expecter struct {
	mock *mock.Mock
}

func (_m *ProcessRepositoryMock) EXPECT() *ProcessRepositoryMock_Expecter {
	return &ProcessRepositoryMock_Expecter{mock: &_m.Mock}
}

// BulkDelete provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) BulkDelete(ctx context.Context, ids []uuid.UUID) error {
	ret := _mock.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for BulkDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []uuid.UUID) error); ok {
		r0 = returnFunc(ctx, ids)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_BulkDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkDelete'
type ProcessRepositoryMock_BulkDelete_Call struct {
	*mock.Call
}

// BulkDelete is a helper method to define mock.On call
//   - ctx
//   - ids
func (_e *ProcessRepositoryMock_Expecter) BulkDelete(ctx interface{}, ids interface{}) *ProcessRepositoryMock_BulkDelete_Call {
	return &ProcessRepositoryMock_BulkDelete_Call{Call: _e.mock.On("BulkDelete", ctx, ids)}
}

func (_c *ProcessRepositoryMock_BulkDelete_Call) Run(run func(ctx context.Context, ids []uuid.UUID)) *ProcessRepositoryMock_BulkDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_BulkDelete_Call) Return(err error) *ProcessRepositoryMock_BulkDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_BulkDelete_Call) RunAndReturn(run func(ctx context.Context, ids []uuid.UUID) error) *ProcessRepositoryMock_BulkDelete_Call {
	_c.Call.Return(run)
	return _c
}

// BulkUpdateStatus provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) BulkUpdateStatus(ctx context.Context, ids []uuid.UUID, status entity.ProcessStatus) error {
	ret := _mock.Called(ctx, ids, status)

	if len(ret) == 0 {
		panic("no return value specified for BulkUpdateStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []uuid.UUID, entity.ProcessStatus) error); ok {
		r0 = returnFunc(ctx, ids, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_BulkUpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BulkUpdateStatus'
type ProcessRepositoryMock_BulkUpdateStatus_Call struct {
	*mock.Call
}

// BulkUpdateStatus is a helper method to define mock.On call
//   - ctx
//   - ids
//   - status
func (_e *ProcessRepositoryMock_Expecter) BulkUpdateStatus(ctx interface{}, ids interface{}, status interface{}) *ProcessRepositoryMock_BulkUpdateStatus_Call {
	return &ProcessRepositoryMock_BulkUpdateStatus_Call{Call: _e.mock.On("BulkUpdateStatus", ctx, ids, status)}
}

func (_c *ProcessRepositoryMock_BulkUpdateStatus_Call) Run(run func(ctx context.Context, ids []uuid.UUID, status entity.ProcessStatus)) *ProcessRepositoryMock_BulkUpdateStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID), args[2].(entity.ProcessStatus))
	})
	return _c
}

func (_c *ProcessRepositoryMock_BulkUpdateStatus_Call) Return(err error) *ProcessRepositoryMock_BulkUpdateStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_BulkUpdateStatus_Call) RunAndReturn(run func(ctx context.Context, ids []uuid.UUID, status entity.ProcessStatus) error) *ProcessRepositoryMock_BulkUpdateStatus_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupOldProcesses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) CleanupOldProcesses(ctx context.Context, olderThan time.Time) (int64, error) {
	ret := _mock.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for CleanupOldProcesses")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time) (int64, error)); ok {
		return returnFunc(ctx, olderThan)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time) int64); ok {
		r0 = returnFunc(ctx, olderThan)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = returnFunc(ctx, olderThan)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_CleanupOldProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupOldProcesses'
type ProcessRepositoryMock_CleanupOldProcesses_Call struct {
	*mock.Call
}

// CleanupOldProcesses is a helper method to define mock.On call
//   - ctx
//   - olderThan
func (_e *ProcessRepositoryMock_Expecter) CleanupOldProcesses(ctx interface{}, olderThan interface{}) *ProcessRepositoryMock_CleanupOldProcesses_Call {
	return &ProcessRepositoryMock_CleanupOldProcesses_Call{Call: _e.mock.On("CleanupOldProcesses", ctx, olderThan)}
}

func (_c *ProcessRepositoryMock_CleanupOldProcesses_Call) Run(run func(ctx context.Context, olderThan time.Time)) *ProcessRepositoryMock_CleanupOldProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *ProcessRepositoryMock_CleanupOldProcesses_Call) Return(n int64, err error) *ProcessRepositoryMock_CleanupOldProcesses_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *ProcessRepositoryMock_CleanupOldProcesses_Call) RunAndReturn(run func(ctx context.Context, olderThan time.Time) (int64, error)) *ProcessRepositoryMock_CleanupOldProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// CountActiveProcesses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) CountActiveProcesses(ctx context.Context) (int64, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountActiveProcesses")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (int64, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) int64); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_CountActiveProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountActiveProcesses'
type ProcessRepositoryMock_CountActiveProcesses_Call struct {
	*mock.Call
}

// CountActiveProcesses is a helper method to define mock.On call
//   - ctx
func (_e *ProcessRepositoryMock_Expecter) CountActiveProcesses(ctx interface{}) *ProcessRepositoryMock_CountActiveProcesses_Call {
	return &ProcessRepositoryMock_CountActiveProcesses_Call{Call: _e.mock.On("CountActiveProcesses", ctx)}
}

func (_c *ProcessRepositoryMock_CountActiveProcesses_Call) Run(run func(ctx context.Context)) *ProcessRepositoryMock_CountActiveProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProcessRepositoryMock_CountActiveProcesses_Call) Return(n int64, err error) *ProcessRepositoryMock_CountActiveProcesses_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *ProcessRepositoryMock_CountActiveProcesses_Call) RunAndReturn(run func(ctx context.Context) (int64, error)) *ProcessRepositoryMock_CountActiveProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) Create(ctx context.Context, process *entity.Process) error {
	ret := _mock.Called(ctx, process)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entity.Process) error); ok {
		r0 = returnFunc(ctx, process)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type ProcessRepositoryMock_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx
//   - process
func (_e *ProcessRepositoryMock_Expecter) Create(ctx interface{}, process interface{}) *ProcessRepositoryMock_Create_Call {
	return &ProcessRepositoryMock_Create_Call{Call: _e.mock.On("Create", ctx, process)}
}

func (_c *ProcessRepositoryMock_Create_Call) Run(run func(ctx context.Context, process *entity.Process)) *ProcessRepositoryMock_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.Process))
	})
	return _c
}

func (_c *ProcessRepositoryMock_Create_Call) Return(err error) *ProcessRepositoryMock_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_Create_Call) RunAndReturn(run func(ctx context.Context, process *entity.Process) error) *ProcessRepositoryMock_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type ProcessRepositoryMock_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *ProcessRepositoryMock_Expecter) Delete(ctx interface{}, id interface{}) *ProcessRepositoryMock_Delete_Call {
	return &ProcessRepositoryMock_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *ProcessRepositoryMock_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *ProcessRepositoryMock_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_Delete_Call) Return(err error) *ProcessRepositoryMock_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_Delete_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *ProcessRepositoryMock_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveProcessesByExecution provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetActiveProcessesByExecution(ctx context.Context, executionID uuid.UUID) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveProcessesByExecution")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, executionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*entity.Process); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetActiveProcessesByExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveProcessesByExecution'
type ProcessRepositoryMock_GetActiveProcessesByExecution_Call struct {
	*mock.Call
}

// GetActiveProcessesByExecution is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) GetActiveProcessesByExecution(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_GetActiveProcessesByExecution_Call {
	return &ProcessRepositoryMock_GetActiveProcessesByExecution_Call{Call: _e.mock.On("GetActiveProcessesByExecution", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_GetActiveProcessesByExecution_Call) Run(run func(ctx context.Context, executionID uuid.UUID)) *ProcessRepositoryMock_GetActiveProcessesByExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetActiveProcessesByExecution_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetActiveProcessesByExecution_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetActiveProcessesByExecution_Call) RunAndReturn(run func(ctx context.Context, executionID uuid.UUID) ([]*entity.Process, error)) *ProcessRepositoryMock_GetActiveProcessesByExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetByDateRange provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByDateRange(ctx context.Context, startDate time.Time, endDate time.Time) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, startDate, endDate)

	if len(ret) == 0 {
		panic("no return value specified for GetByDateRange")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, startDate, endDate)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Time, time.Time) []*entity.Process); ok {
		r0 = returnFunc(ctx, startDate, endDate)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Time, time.Time) error); ok {
		r1 = returnFunc(ctx, startDate, endDate)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByDateRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByDateRange'
type ProcessRepositoryMock_GetByDateRange_Call struct {
	*mock.Call
}

// GetByDateRange is a helper method to define mock.On call
//   - ctx
//   - startDate
//   - endDate
func (_e *ProcessRepositoryMock_Expecter) GetByDateRange(ctx interface{}, startDate interface{}, endDate interface{}) *ProcessRepositoryMock_GetByDateRange_Call {
	return &ProcessRepositoryMock_GetByDateRange_Call{Call: _e.mock.On("GetByDateRange", ctx, startDate, endDate)}
}

func (_c *ProcessRepositoryMock_GetByDateRange_Call) Run(run func(ctx context.Context, startDate time.Time, endDate time.Time)) *ProcessRepositoryMock_GetByDateRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time), args[2].(time.Time))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByDateRange_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetByDateRange_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByDateRange_Call) RunAndReturn(run func(ctx context.Context, startDate time.Time, endDate time.Time) ([]*entity.Process, error)) *ProcessRepositoryMock_GetByDateRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetByExecutionID provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByExecutionID(ctx context.Context, executionID uuid.UUID) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetByExecutionID")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, executionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*entity.Process); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByExecutionID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByExecutionID'
type ProcessRepositoryMock_GetByExecutionID_Call struct {
	*mock.Call
}

// GetByExecutionID is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) GetByExecutionID(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_GetByExecutionID_Call {
	return &ProcessRepositoryMock_GetByExecutionID_Call{Call: _e.mock.On("GetByExecutionID", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_GetByExecutionID_Call) Run(run func(ctx context.Context, executionID uuid.UUID)) *ProcessRepositoryMock_GetByExecutionID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByExecutionID_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetByExecutionID_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByExecutionID_Call) RunAndReturn(run func(ctx context.Context, executionID uuid.UUID) ([]*entity.Process, error)) *ProcessRepositoryMock_GetByExecutionID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (*entity.Process, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*entity.Process, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) *entity.Process); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type ProcessRepositoryMock_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *ProcessRepositoryMock_Expecter) GetByID(ctx interface{}, id interface{}) *ProcessRepositoryMock_GetByID_Call {
	return &ProcessRepositoryMock_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *ProcessRepositoryMock_GetByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *ProcessRepositoryMock_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByID_Call) Return(process *entity.Process, err error) *ProcessRepositoryMock_GetByID_Call {
	_c.Call.Return(process, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (*entity.Process, error)) *ProcessRepositoryMock_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByPID provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByPID(ctx context.Context, pid int) (*entity.Process, error) {
	ret := _mock.Called(ctx, pid)

	if len(ret) == 0 {
		panic("no return value specified for GetByPID")
	}

	var r0 *entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) (*entity.Process, error)); ok {
		return returnFunc(ctx, pid)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) *entity.Process); ok {
		r0 = returnFunc(ctx, pid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, pid)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByPID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByPID'
type ProcessRepositoryMock_GetByPID_Call struct {
	*mock.Call
}

// GetByPID is a helper method to define mock.On call
//   - ctx
//   - pid
func (_e *ProcessRepositoryMock_Expecter) GetByPID(ctx interface{}, pid interface{}) *ProcessRepositoryMock_GetByPID_Call {
	return &ProcessRepositoryMock_GetByPID_Call{Call: _e.mock.On("GetByPID", ctx, pid)}
}

func (_c *ProcessRepositoryMock_GetByPID_Call) Run(run func(ctx context.Context, pid int)) *ProcessRepositoryMock_GetByPID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByPID_Call) Return(process *entity.Process, err error) *ProcessRepositoryMock_GetByPID_Call {
	_c.Call.Return(process, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByPID_Call) RunAndReturn(run func(ctx context.Context, pid int) (*entity.Process, error)) *ProcessRepositoryMock_GetByPID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByStatus provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByStatus(ctx context.Context, status entity.ProcessStatus) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, status)

	if len(ret) == 0 {
		panic("no return value specified for GetByStatus")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, entity.ProcessStatus) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, status)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, entity.ProcessStatus) []*entity.Process); ok {
		r0 = returnFunc(ctx, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, entity.ProcessStatus) error); ok {
		r1 = returnFunc(ctx, status)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByStatus'
type ProcessRepositoryMock_GetByStatus_Call struct {
	*mock.Call
}

// GetByStatus is a helper method to define mock.On call
//   - ctx
//   - status
func (_e *ProcessRepositoryMock_Expecter) GetByStatus(ctx interface{}, status interface{}) *ProcessRepositoryMock_GetByStatus_Call {
	return &ProcessRepositoryMock_GetByStatus_Call{Call: _e.mock.On("GetByStatus", ctx, status)}
}

func (_c *ProcessRepositoryMock_GetByStatus_Call) Run(run func(ctx context.Context, status entity.ProcessStatus)) *ProcessRepositoryMock_GetByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(entity.ProcessStatus))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByStatus_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetByStatus_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByStatus_Call) RunAndReturn(run func(ctx context.Context, status entity.ProcessStatus) ([]*entity.Process, error)) *ProcessRepositoryMock_GetByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetByStatuses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetByStatuses(ctx context.Context, statuses []entity.ProcessStatus) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, statuses)

	if len(ret) == 0 {
		panic("no return value specified for GetByStatuses")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []entity.ProcessStatus) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, statuses)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, []entity.ProcessStatus) []*entity.Process); ok {
		r0 = returnFunc(ctx, statuses)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, []entity.ProcessStatus) error); ok {
		r1 = returnFunc(ctx, statuses)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetByStatuses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByStatuses'
type ProcessRepositoryMock_GetByStatuses_Call struct {
	*mock.Call
}

// GetByStatuses is a helper method to define mock.On call
//   - ctx
//   - statuses
func (_e *ProcessRepositoryMock_Expecter) GetByStatuses(ctx interface{}, statuses interface{}) *ProcessRepositoryMock_GetByStatuses_Call {
	return &ProcessRepositoryMock_GetByStatuses_Call{Call: _e.mock.On("GetByStatuses", ctx, statuses)}
}

func (_c *ProcessRepositoryMock_GetByStatuses_Call) Run(run func(ctx context.Context, statuses []entity.ProcessStatus)) *ProcessRepositoryMock_GetByStatuses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]entity.ProcessStatus))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetByStatuses_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetByStatuses_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetByStatuses_Call) RunAndReturn(run func(ctx context.Context, statuses []entity.ProcessStatus) ([]*entity.Process, error)) *ProcessRepositoryMock_GetByStatuses_Call {
	_c.Call.Return(run)
	return _c
}

// GetCompleted provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetCompleted(ctx context.Context, limit int) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetCompleted")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []*entity.Process); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCompleted'
type ProcessRepositoryMock_GetCompleted_Call struct {
	*mock.Call
}

// GetCompleted is a helper method to define mock.On call
//   - ctx
//   - limit
func (_e *ProcessRepositoryMock_Expecter) GetCompleted(ctx interface{}, limit interface{}) *ProcessRepositoryMock_GetCompleted_Call {
	return &ProcessRepositoryMock_GetCompleted_Call{Call: _e.mock.On("GetCompleted", ctx, limit)}
}

func (_c *ProcessRepositoryMock_GetCompleted_Call) Run(run func(ctx context.Context, limit int)) *ProcessRepositoryMock_GetCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetCompleted_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetCompleted_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetCompleted_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]*entity.Process, error)) *ProcessRepositoryMock_GetCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// GetHighResourceProcesses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetHighResourceProcesses(ctx context.Context, cpuThreshold float64, memoryThreshold uint64) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, cpuThreshold, memoryThreshold)

	if len(ret) == 0 {
		panic("no return value specified for GetHighResourceProcesses")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, float64, uint64) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, cpuThreshold, memoryThreshold)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, float64, uint64) []*entity.Process); ok {
		r0 = returnFunc(ctx, cpuThreshold, memoryThreshold)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, float64, uint64) error); ok {
		r1 = returnFunc(ctx, cpuThreshold, memoryThreshold)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetHighResourceProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHighResourceProcesses'
type ProcessRepositoryMock_GetHighResourceProcesses_Call struct {
	*mock.Call
}

// GetHighResourceProcesses is a helper method to define mock.On call
//   - ctx
//   - cpuThreshold
//   - memoryThreshold
func (_e *ProcessRepositoryMock_Expecter) GetHighResourceProcesses(ctx interface{}, cpuThreshold interface{}, memoryThreshold interface{}) *ProcessRepositoryMock_GetHighResourceProcesses_Call {
	return &ProcessRepositoryMock_GetHighResourceProcesses_Call{Call: _e.mock.On("GetHighResourceProcesses", ctx, cpuThreshold, memoryThreshold)}
}

func (_c *ProcessRepositoryMock_GetHighResourceProcesses_Call) Run(run func(ctx context.Context, cpuThreshold float64, memoryThreshold uint64)) *ProcessRepositoryMock_GetHighResourceProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(float64), args[2].(uint64))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetHighResourceProcesses_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetHighResourceProcesses_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetHighResourceProcesses_Call) RunAndReturn(run func(ctx context.Context, cpuThreshold float64, memoryThreshold uint64) ([]*entity.Process, error)) *ProcessRepositoryMock_GetHighResourceProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// GetLongRunningProcesses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetLongRunningProcesses(ctx context.Context, threshold time.Duration) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, threshold)

	if len(ret) == 0 {
		panic("no return value specified for GetLongRunningProcesses")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, threshold)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, time.Duration) []*entity.Process); ok {
		r0 = returnFunc(ctx, threshold)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, time.Duration) error); ok {
		r1 = returnFunc(ctx, threshold)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetLongRunningProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLongRunningProcesses'
type ProcessRepositoryMock_GetLongRunningProcesses_Call struct {
	*mock.Call
}

// GetLongRunningProcesses is a helper method to define mock.On call
//   - ctx
//   - threshold
func (_e *ProcessRepositoryMock_Expecter) GetLongRunningProcesses(ctx interface{}, threshold interface{}) *ProcessRepositoryMock_GetLongRunningProcesses_Call {
	return &ProcessRepositoryMock_GetLongRunningProcesses_Call{Call: _e.mock.On("GetLongRunningProcesses", ctx, threshold)}
}

func (_c *ProcessRepositoryMock_GetLongRunningProcesses_Call) Run(run func(ctx context.Context, threshold time.Duration)) *ProcessRepositoryMock_GetLongRunningProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Duration))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetLongRunningProcesses_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetLongRunningProcesses_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetLongRunningProcesses_Call) RunAndReturn(run func(ctx context.Context, threshold time.Duration) ([]*entity.Process, error)) *ProcessRepositoryMock_GetLongRunningProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// GetProcessStats provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetProcessStats(ctx context.Context, executionID *uuid.UUID) (*ProcessStats, error) {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetProcessStats")
	}

	var r0 *ProcessStats
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *uuid.UUID) (*ProcessStats, error)); ok {
		return returnFunc(ctx, executionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *uuid.UUID) *ProcessStats); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ProcessStats)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *uuid.UUID) error); ok {
		r1 = returnFunc(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetProcessStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProcessStats'
type ProcessRepositoryMock_GetProcessStats_Call struct {
	*mock.Call
}

// GetProcessStats is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) GetProcessStats(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_GetProcessStats_Call {
	return &ProcessRepositoryMock_GetProcessStats_Call{Call: _e.mock.On("GetProcessStats", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_GetProcessStats_Call) Run(run func(ctx context.Context, executionID *uuid.UUID)) *ProcessRepositoryMock_GetProcessStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetProcessStats_Call) Return(processStats *ProcessStats, err error) *ProcessRepositoryMock_GetProcessStats_Call {
	_c.Call.Return(processStats, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetProcessStats_Call) RunAndReturn(run func(ctx context.Context, executionID *uuid.UUID) (*ProcessStats, error)) *ProcessRepositoryMock_GetProcessStats_Call {
	_c.Call.Return(run)
	return _c
}

// GetRecentProcesses provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetRecentProcesses(ctx context.Context, limit int) ([]*entity.Process, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetRecentProcesses")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]*entity.Process, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []*entity.Process); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetRecentProcesses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRecentProcesses'
type ProcessRepositoryMock_GetRecentProcesses_Call struct {
	*mock.Call
}

// GetRecentProcesses is a helper method to define mock.On call
//   - ctx
//   - limit
func (_e *ProcessRepositoryMock_Expecter) GetRecentProcesses(ctx interface{}, limit interface{}) *ProcessRepositoryMock_GetRecentProcesses_Call {
	return &ProcessRepositoryMock_GetRecentProcesses_Call{Call: _e.mock.On("GetRecentProcesses", ctx, limit)}
}

func (_c *ProcessRepositoryMock_GetRecentProcesses_Call) Run(run func(ctx context.Context, limit int)) *ProcessRepositoryMock_GetRecentProcesses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetRecentProcesses_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetRecentProcesses_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetRecentProcesses_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]*entity.Process, error)) *ProcessRepositoryMock_GetRecentProcesses_Call {
	_c.Call.Return(run)
	return _c
}

// GetResourceUsageSummary provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetResourceUsageSummary(ctx context.Context, executionID *uuid.UUID) (*ResourceUsageSummary, error) {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for GetResourceUsageSummary")
	}

	var r0 *ResourceUsageSummary
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *uuid.UUID) (*ResourceUsageSummary, error)); ok {
		return returnFunc(ctx, executionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *uuid.UUID) *ResourceUsageSummary); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ResourceUsageSummary)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *uuid.UUID) error); ok {
		r1 = returnFunc(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetResourceUsageSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetResourceUsageSummary'
type ProcessRepositoryMock_GetResourceUsageSummary_Call struct {
	*mock.Call
}

// GetResourceUsageSummary is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) GetResourceUsageSummary(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_GetResourceUsageSummary_Call {
	return &ProcessRepositoryMock_GetResourceUsageSummary_Call{Call: _e.mock.On("GetResourceUsageSummary", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_GetResourceUsageSummary_Call) Run(run func(ctx context.Context, executionID *uuid.UUID)) *ProcessRepositoryMock_GetResourceUsageSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetResourceUsageSummary_Call) Return(resourceUsageSummary *ResourceUsageSummary, err error) *ProcessRepositoryMock_GetResourceUsageSummary_Call {
	_c.Call.Return(resourceUsageSummary, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetResourceUsageSummary_Call) RunAndReturn(run func(ctx context.Context, executionID *uuid.UUID) (*ResourceUsageSummary, error)) *ProcessRepositoryMock_GetResourceUsageSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunning provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) GetRunning(ctx context.Context) ([]*entity.Process, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetRunning")
	}

	var r0 []*entity.Process
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]*entity.Process, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []*entity.Process); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*entity.Process)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_GetRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunning'
type ProcessRepositoryMock_GetRunning_Call struct {
	*mock.Call
}

// GetRunning is a helper method to define mock.On call
//   - ctx
func (_e *ProcessRepositoryMock_Expecter) GetRunning(ctx interface{}) *ProcessRepositoryMock_GetRunning_Call {
	return &ProcessRepositoryMock_GetRunning_Call{Call: _e.mock.On("GetRunning", ctx)}
}

func (_c *ProcessRepositoryMock_GetRunning_Call) Run(run func(ctx context.Context)) *ProcessRepositoryMock_GetRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ProcessRepositoryMock_GetRunning_Call) Return(processs []*entity.Process, err error) *ProcessRepositoryMock_GetRunning_Call {
	_c.Call.Return(processs, err)
	return _c
}

func (_c *ProcessRepositoryMock_GetRunning_Call) RunAndReturn(run func(ctx context.Context) ([]*entity.Process, error)) *ProcessRepositoryMock_GetRunning_Call {
	_c.Call.Return(run)
	return _c
}

// MarkCompleted provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) MarkCompleted(ctx context.Context, id uuid.UUID, endTime time.Time, exitCode *int) error {
	ret := _mock.Called(ctx, id, endTime, exitCode)

	if len(ret) == 0 {
		panic("no return value specified for MarkCompleted")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, time.Time, *int) error); ok {
		r0 = returnFunc(ctx, id, endTime, exitCode)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_MarkCompleted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkCompleted'
type ProcessRepositoryMock_MarkCompleted_Call struct {
	*mock.Call
}

// MarkCompleted is a helper method to define mock.On call
//   - ctx
//   - id
//   - endTime
//   - exitCode
func (_e *ProcessRepositoryMock_Expecter) MarkCompleted(ctx interface{}, id interface{}, endTime interface{}, exitCode interface{}) *ProcessRepositoryMock_MarkCompleted_Call {
	return &ProcessRepositoryMock_MarkCompleted_Call{Call: _e.mock.On("MarkCompleted", ctx, id, endTime, exitCode)}
}

func (_c *ProcessRepositoryMock_MarkCompleted_Call) Run(run func(ctx context.Context, id uuid.UUID, endTime time.Time, exitCode *int)) *ProcessRepositoryMock_MarkCompleted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(time.Time), args[3].(*int))
	})
	return _c
}

func (_c *ProcessRepositoryMock_MarkCompleted_Call) Return(err error) *ProcessRepositoryMock_MarkCompleted_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_MarkCompleted_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, endTime time.Time, exitCode *int) error) *ProcessRepositoryMock_MarkCompleted_Call {
	_c.Call.Return(run)
	return _c
}

// MarkFailed provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) MarkFailed(ctx context.Context, id uuid.UUID, endTime time.Time, error1 string) error {
	ret := _mock.Called(ctx, id, endTime, error1)

	if len(ret) == 0 {
		panic("no return value specified for MarkFailed")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, time.Time, string) error); ok {
		r0 = returnFunc(ctx, id, endTime, error1)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_MarkFailed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkFailed'
type ProcessRepositoryMock_MarkFailed_Call struct {
	*mock.Call
}

// MarkFailed is a helper method to define mock.On call
//   - ctx
//   - id
//   - endTime
//   - error1
func (_e *ProcessRepositoryMock_Expecter) MarkFailed(ctx interface{}, id interface{}, endTime interface{}, error1 interface{}) *ProcessRepositoryMock_MarkFailed_Call {
	return &ProcessRepositoryMock_MarkFailed_Call{Call: _e.mock.On("MarkFailed", ctx, id, endTime, error1)}
}

func (_c *ProcessRepositoryMock_MarkFailed_Call) Run(run func(ctx context.Context, id uuid.UUID, endTime time.Time, error1 string)) *ProcessRepositoryMock_MarkFailed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(time.Time), args[3].(string))
	})
	return _c
}

func (_c *ProcessRepositoryMock_MarkFailed_Call) Return(err error) *ProcessRepositoryMock_MarkFailed_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_MarkFailed_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, endTime time.Time, error1 string) error) *ProcessRepositoryMock_MarkFailed_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateProcessesByExecution provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) TerminateProcessesByExecution(ctx context.Context, executionID uuid.UUID) error {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for TerminateProcessesByExecution")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_TerminateProcessesByExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateProcessesByExecution'
type ProcessRepositoryMock_TerminateProcessesByExecution_Call struct {
	*mock.Call
}

// TerminateProcessesByExecution is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) TerminateProcessesByExecution(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_TerminateProcessesByExecution_Call {
	return &ProcessRepositoryMock_TerminateProcessesByExecution_Call{Call: _e.mock.On("TerminateProcessesByExecution", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_TerminateProcessesByExecution_Call) Run(run func(ctx context.Context, executionID uuid.UUID)) *ProcessRepositoryMock_TerminateProcessesByExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_TerminateProcessesByExecution_Call) Return(err error) *ProcessRepositoryMock_TerminateProcessesByExecution_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_TerminateProcessesByExecution_Call) RunAndReturn(run func(ctx context.Context, executionID uuid.UUID) error) *ProcessRepositoryMock_TerminateProcessesByExecution_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) Update(ctx context.Context, process *entity.Process) error {
	ret := _mock.Called(ctx, process)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *entity.Process) error); ok {
		r0 = returnFunc(ctx, process)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type ProcessRepositoryMock_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx
//   - process
func (_e *ProcessRepositoryMock_Expecter) Update(ctx interface{}, process interface{}) *ProcessRepositoryMock_Update_Call {
	return &ProcessRepositoryMock_Update_Call{Call: _e.mock.On("Update", ctx, process)}
}

func (_c *ProcessRepositoryMock_Update_Call) Run(run func(ctx context.Context, process *entity.Process)) *ProcessRepositoryMock_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*entity.Process))
	})
	return _c
}

func (_c *ProcessRepositoryMock_Update_Call) Return(err error) *ProcessRepositoryMock_Update_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_Update_Call) RunAndReturn(run func(ctx context.Context, process *entity.Process) error) *ProcessRepositoryMock_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePID provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) UpdatePID(ctx context.Context, id uuid.UUID, pid int) error {
	ret := _mock.Called(ctx, id, pid)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePID")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int) error); ok {
		r0 = returnFunc(ctx, id, pid)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_UpdatePID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePID'
type ProcessRepositoryMock_UpdatePID_Call struct {
	*mock.Call
}

// UpdatePID is a helper method to define mock.On call
//   - ctx
//   - id
//   - pid
func (_e *ProcessRepositoryMock_Expecter) UpdatePID(ctx interface{}, id interface{}, pid interface{}) *ProcessRepositoryMock_UpdatePID_Call {
	return &ProcessRepositoryMock_UpdatePID_Call{Call: _e.mock.On("UpdatePID", ctx, id, pid)}
}

func (_c *ProcessRepositoryMock_UpdatePID_Call) Run(run func(ctx context.Context, id uuid.UUID, pid int)) *ProcessRepositoryMock_UpdatePID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int))
	})
	return _c
}

func (_c *ProcessRepositoryMock_UpdatePID_Call) Return(err error) *ProcessRepositoryMock_UpdatePID_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_UpdatePID_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, pid int) error) *ProcessRepositoryMock_UpdatePID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateResourceUsage provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) UpdateResourceUsage(ctx context.Context, id uuid.UUID, cpuUsage float64, memoryUsage uint64) error {
	ret := _mock.Called(ctx, id, cpuUsage, memoryUsage)

	if len(ret) == 0 {
		panic("no return value specified for UpdateResourceUsage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, float64, uint64) error); ok {
		r0 = returnFunc(ctx, id, cpuUsage, memoryUsage)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_UpdateResourceUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateResourceUsage'
type ProcessRepositoryMock_UpdateResourceUsage_Call struct {
	*mock.Call
}

// UpdateResourceUsage is a helper method to define mock.On call
//   - ctx
//   - id
//   - cpuUsage
//   - memoryUsage
func (_e *ProcessRepositoryMock_Expecter) UpdateResourceUsage(ctx interface{}, id interface{}, cpuUsage interface{}, memoryUsage interface{}) *ProcessRepositoryMock_UpdateResourceUsage_Call {
	return &ProcessRepositoryMock_UpdateResourceUsage_Call{Call: _e.mock.On("UpdateResourceUsage", ctx, id, cpuUsage, memoryUsage)}
}

func (_c *ProcessRepositoryMock_UpdateResourceUsage_Call) Run(run func(ctx context.Context, id uuid.UUID, cpuUsage float64, memoryUsage uint64)) *ProcessRepositoryMock_UpdateResourceUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(float64), args[3].(uint64))
	})
	return _c
}

func (_c *ProcessRepositoryMock_UpdateResourceUsage_Call) Return(err error) *ProcessRepositoryMock_UpdateResourceUsage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_UpdateResourceUsage_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, cpuUsage float64, memoryUsage uint64) error) *ProcessRepositoryMock_UpdateResourceUsage_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStatus provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) UpdateStatus(ctx context.Context, id uuid.UUID, status entity.ProcessStatus) error {
	ret := _mock.Called(ctx, id, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStatus")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, entity.ProcessStatus) error); ok {
		r0 = returnFunc(ctx, id, status)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ProcessRepositoryMock_UpdateStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStatus'
type ProcessRepositoryMock_UpdateStatus_Call struct {
	*mock.Call
}

// UpdateStatus is a helper method to define mock.On call
//   - ctx
//   - id
//   - status
func (_e *ProcessRepositoryMock_Expecter) UpdateStatus(ctx interface{}, id interface{}, status interface{}) *ProcessRepositoryMock_UpdateStatus_Call {
	return &ProcessRepositoryMock_UpdateStatus_Call{Call: _e.mock.On("UpdateStatus", ctx, id, status)}
}

func (_c *ProcessRepositoryMock_UpdateStatus_Call) Run(run func(ctx context.Context, id uuid.UUID, status entity.ProcessStatus)) *ProcessRepositoryMock_UpdateStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(entity.ProcessStatus))
	})
	return _c
}

func (_c *ProcessRepositoryMock_UpdateStatus_Call) Return(err error) *ProcessRepositoryMock_UpdateStatus_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ProcessRepositoryMock_UpdateStatus_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID, status entity.ProcessStatus) error) *ProcessRepositoryMock_UpdateStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateExecutionExists provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) ValidateExecutionExists(ctx context.Context, executionID uuid.UUID) (bool, error) {
	ret := _mock.Called(ctx, executionID)

	if len(ret) == 0 {
		panic("no return value specified for ValidateExecutionExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (bool, error)); ok {
		return returnFunc(ctx, executionID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok {
		r0 = returnFunc(ctx, executionID)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, executionID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_ValidateExecutionExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateExecutionExists'
type ProcessRepositoryMock_ValidateExecutionExists_Call struct {
	*mock.Call
}

// ValidateExecutionExists is a helper method to define mock.On call
//   - ctx
//   - executionID
func (_e *ProcessRepositoryMock_Expecter) ValidateExecutionExists(ctx interface{}, executionID interface{}) *ProcessRepositoryMock_ValidateExecutionExists_Call {
	return &ProcessRepositoryMock_ValidateExecutionExists_Call{Call: _e.mock.On("ValidateExecutionExists", ctx, executionID)}
}

func (_c *ProcessRepositoryMock_ValidateExecutionExists_Call) Run(run func(ctx context.Context, executionID uuid.UUID)) *ProcessRepositoryMock_ValidateExecutionExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_ValidateExecutionExists_Call) Return(b bool, err error) *ProcessRepositoryMock_ValidateExecutionExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ProcessRepositoryMock_ValidateExecutionExists_Call) RunAndReturn(run func(ctx context.Context, executionID uuid.UUID) (bool, error)) *ProcessRepositoryMock_ValidateExecutionExists_Call {
	_c.Call.Return(run)
	return _c
}

// ValidateProcessExists provides a mock function for the type ProcessRepositoryMock
func (_mock *ProcessRepositoryMock) ValidateProcessExists(ctx context.Context, id uuid.UUID) (bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ValidateProcessExists")
	}

	var r0 bool
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) bool); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(bool)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ProcessRepositoryMock_ValidateProcessExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ValidateProcessExists'
type ProcessRepositoryMock_ValidateProcessExists_Call struct {
	*mock.Call
}

// ValidateProcessExists is a helper method to define mock.On call
//   - ctx
//   - id
func (_e *ProcessRepositoryMock_Expecter) ValidateProcessExists(ctx interface{}, id interface{}) *ProcessRepositoryMock_ValidateProcessExists_Call {
	return &ProcessRepositoryMock_ValidateProcessExists_Call{Call: _e.mock.On("ValidateProcessExists", ctx, id)}
}

func (_c *ProcessRepositoryMock_ValidateProcessExists_Call) Run(run func(ctx context.Context, id uuid.UUID)) *ProcessRepositoryMock_ValidateProcessExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ProcessRepositoryMock_ValidateProcessExists_Call) Return(b bool, err error) *ProcessRepositoryMock_ValidateProcessExists_Call {
	_c.Call.Return(b, err)
	return _c
}

func (_c *ProcessRepositoryMock_ValidateProcessExists_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (bool, error)) *ProcessRepositoryMock_ValidateProcessExists_Call {
	_c.Call.Return(run)
	return _c
}
